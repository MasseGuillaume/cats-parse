<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="paradox-docs">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="paradox-docs">
<link rel="shortcut icon" href="assets/images/favicon.png">
<title>cats-parse</title>
<link rel="stylesheet" href="assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="assets/stylesheets/application-palette.22915126.css">
<meta name="theme-color" content="#ef5350" />
<link rel="stylesheet" href="lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="lib/prettify/prettify.css">
<script src="assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,400i,700|Ubuntu+Mono">
<style>
body,input{font-family:"Ubuntu","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Ubuntu Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="assets/fonts/font-awesome.css">
<link rel="stylesheet" href="assets/fonts/material-icons.css">
<link rel="stylesheet" href="assets/stylesheets/paradox-material-theme.css">
</head>
<body
data-md-color-primary="red"
data-md-color-accent="orange"
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="index.html" title="cats-parse" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
cats-parse
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/typelevel/cats-parse"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
typelevel/cats-parse
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="index.html" title="cats-parse" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="index.html" title="cats-parse">
cats-parse
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/typelevel/cats-parse"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
typelevel/cats-parse
</div>
</a>

</div>
<ul>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="index.html#cats-parse" class="header">cats-parse</a>
  <ul>
    <li><a href="index.html#tutorial" class="header">Tutorial</a></li>
    <li><a href="index.html#json-parser-example" class="header">JSON parser example</a></li>
    <li><a href="index.html#performance" class="header">Performance</a></li>
    <li><a href="index.html#migrating-from-fastparse" class="header">Migrating from Fastparse</a></li>
    <li><a href="index.html#getting-and-giving-help" class="header">Getting and Giving Help</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.3-2-0133cf6
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="index.html#cats-parse" class="header">cats-parse</a>
  <ul>
    <li><a href="index.html#tutorial" class="header">Tutorial</a></li>
    <li><a href="index.html#json-parser-example" class="header">JSON parser example</a></li>
    <li><a href="index.html#performance" class="header">Performance</a></li>
    <li><a href="index.html#migrating-from-fastparse" class="header">Migrating from Fastparse</a></li>
    <li><a href="index.html#getting-and-giving-help" class="header">Getting and Giving Help</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#cats-parse" name="cats-parse" class="anchor"><span class="anchor-link"></span></a>cats-parse</h1>
<p><a href="https://github.com/typelevel/cats-parse/actions?query=workflow%3A%22Continuous+Integration%22"><img src="https://github.com/typelevel/cats-parse/workflows/Continuous%20Integration/badge.svg" alt="Continuous Integration" /></a><a href="https://codecov.io/gh/typelevel/cats-parse"><img src="https://codecov.io/gh/typelevel/cats-parse/branch/main/graph/badge.svg" alt="codecov" /></a></p>
<p>A parsing library for the cats ecosystem.</p>
<p>To use in sbt add, the following to your <code>libraryDependencies</code>: </p>
<pre class="prettyprint"><code class="language-scala">// use this snippet for the JVM
libraryDependencies += &quot;org.typelevel&quot; %% &quot;cats-parse&quot; % &quot;0.3.5&quot;

// use this snippet for JS, or cross-building
libraryDependencies += &quot;org.typelevel&quot; %%% &quot;cats-parse&quot; % &quot;0.3.5&quot;
</code></pre>
<p>The <a href="https://oss.sonatype.org/service/local/repositories/releases/archive/org/typelevel/cats-parse_2.13/0.3.5/cats-parse_2.13-0.3.5-javadoc.jar/!/cats/parse/index.html">API docs</a> are published.</p>
<p>Why another parsing library? See this <a href="https://posco.medium.com/designing-a-parsing-library-in-scala-d5076de52536">blog post detailing the design</a>. To reiterate, this library has a few goals:</p>
<ol>
  <li>Compatability: should work on all scala platforms and recent versions. Currently it supports JVM, JS on versions 2.11, 2.12, 2.13, and 3. The core library should have minimal dependencies. Currently this library only depends on cats.</li>
  <li>Excellent performance: should be as fast or faster than any parser combinator that has comparable scala version support.</li>
  <li>Cats friendliness: method names match cats style, and out of the box support for cats typeclasses.</li>
  <li>Precise errors: following the <a href="https://hackage.haskell.org/package/trifecta">Haskell Trifecta parsing library</a>, backtracking is opt-in vs opt-out. This design tends to make it easier to write parsers that point correctly to failure points.</li>
  <li>Safety: by separating Parser0, a parser that may consume no input, from Parser, a parser must consume at least one character on success. Most combinators and methods can be made safer to use and less prone to runtime errors.</li>
  <li>Stability: we are very reluctant to break compatibility between versions. We want to put a minimal tax on users to stay on the latest versions.</li>
</ol>
<h1><a href="#tutorial" name="tutorial" class="anchor"><span class="anchor-link"></span></a>Tutorial</h1>
<h2><a href="#simple-parser" name="simple-parser" class="anchor"><span class="anchor-link"></span></a>Simple parser</h2>
<p>The library provides a set of simple parsers which might be combined to create any parsing logic. The simplest parser is <code>Parser.anyChar</code> which is successful where there is one char at the input. It has type <code>Parser[Char]</code> which means it returns one parsed char.</p>
<p>To provide any input to parser one need to use <code>parse</code> method.</p>
<pre class="prettyprint"><code class="language-scala">import cats.parse.Parser

val p: Parser[Char] = Parser.anyChar
// p: Parser[Char] = AnyChar

p.parse(&quot;t&quot;)
// res1: Either[Parser.Error, (String, Char)] = Right(value = (&quot;&quot;, &#39;t&#39;))
// res0: Either[Error, Tuple2[String, Char]] = Right((,t))
p.parse(&quot;&quot;)
// res2: Either[Parser.Error, (String, Char)] = Left(
//   value = Error(
//     failedAtOffset = 0,
//     expected = NonEmptyList(
//       head = InRange(offset = 0, lower = &#39;\u0000&#39;, upper = &#39;\uffff&#39;),
//       tail = List()
//     )
//   )
// )
// res1: Either[Error, Tuple2[String, Char]] = Left(Error(0,NonEmptyList(InRange(0,,))))
p.parse(&quot;two&quot;)
// res3: Either[Parser.Error, (String, Char)] = Right(value = (&quot;wo&quot;, &#39;t&#39;))
</code></pre>
<p>Notice the return type. <code>Tuple2[String, Char]</code> contains the rest of the input string and one parsed char if parsing was successful. It returns <code>Left</code> with error message if there was some parsing error.</p>
<h2><a href="#mapping-output" name="mapping-output" class="anchor"><span class="anchor-link"></span></a>Mapping output</h2>
<p>The output of the parser might be processed with <code>map</code> method:</p>
<pre class="prettyprint"><code class="language-scala">import cats.parse.Parser

case class CharWrapper(value: Char)  

val p: Parser[CharWrapper] = Parser.anyChar.map(char =&gt; CharWrapper(char))
// p: Parser[CharWrapper] = Map(parser = AnyChar, fn = &lt;function1&gt;)

p.parse(&quot;t&quot;)
// res5: Either[Parser.Error, (String, CharWrapper)] = Right(
//   value = (&quot;&quot;, CharWrapper(value = &#39;t&#39;))
// )
</code></pre>
<p>There are built-in methods for mapping the output to types <code>String</code> or <code>Unit</code>:</p>
<pre class="prettyprint"><code class="language-scala">import cats.parse.Rfc5234.digit
import cats.parse.Parser

/* String */

val p2: Parser[String] = digit.map((c: Char) =&gt; c.toString)
// p2: Parser[String] = Map(
//   parser = CharIn(
//     min = 48,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//     ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//   ),
//   fn = &lt;function1&gt;
// )
// is analog to
val p3: Parser[String] = digit.string
// p3: Parser[String] = StringP(
//   parser = CharIn(
//     min = 48,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//     ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//   )
// )

p3.parse(&quot;1&quot;)
// res7: Either[Parser.Error, (String, String)] = Right(value = (&quot;&quot;, &quot;1&quot;))
// res0: Either[Error, Tuple2[String, String]] = Right((,1))

/* Unit */

val p4: Parser[Unit] = digit.map(_ =&gt; ())
// p4: Parser[Unit] = Map(
//   parser = CharIn(
//     min = 48,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//     ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//   ),
//   fn = &lt;function1&gt;
// )
// is analog to
val p5: Parser[Unit] = digit.void
// p5: Parser[Unit] = Void(
//   parser = CharIn(
//     min = 48,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//     ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//   )
// )

p5.parse(&quot;1&quot;)
// res8: Either[Parser.Error, (String, Unit)] = Right(value = (&quot;&quot;, ()))
</code></pre>
<h2><a href="#combining-parsers" name="combining-parsers" class="anchor"><span class="anchor-link"></span></a>Combining parsers</h2>
<p>The parsers might be combined through operators:</p>
<ul>
  <li><code>~</code> - product. Allows continuing parsing if the left side was successful;</li>
  <li><code>&lt;*</code>, <code>*&gt;</code> - productL and productR. Works just like product but drop part of result;</li>
  <li><code>surroundedBy</code> - identical to <code>border *&gt; parsingResult &lt;* border</code>;</li>
  <li><code>between</code> - identical to <code>border1 *&gt; parsingResult &lt;* border2</code>;</li>
  <li><code>|</code>, <code>orElse</code>. Parser will be successful if any of sides is successful.</li>
</ul>
<p>For this example we&rsquo;ll be using <code>cats.parse.Rfc5234</code> package which contains such parsers as <code>alpha</code> (Latin alphabet) and <code>sp</code> (whitespace). </p>
<pre class="prettyprint"><code class="language-scala">import cats.parse.Rfc5234.{sp, alpha, digit}
import cats.parse.Parser

/* Product */

// the sp parser won&#39;t return the whitespace, it just returns Unit if it successful
val p1: Parser[(Char, Unit)] = alpha ~ sp
// p1: Parser[(Char, Unit)] = Prod(
//   first = CharIn(
//     min = 65,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//     ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//   ),
//   second = Void(
//     parser = CharIn(
//       min = 32,
//       bitSet = {0},
//       ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//     )
//   )
// )

p1.parse(&quot;t&quot;)
// res10: Either[Parser.Error, (String, (Char, Unit))] = Left(
//   value = Error(
//     failedAtOffset = 1,
//     expected = NonEmptyList(
//       head = InRange(offset = 1, lower = &#39; &#39;, upper = &#39; &#39;),
//       tail = List()
//     )
//   )
// )
// res0: Either[Error, Tuple2[String, Tuple2[Char, Unit]]] = Left(Error(1,NonEmptyList(InRange(1, , ))))
p1.parse(&quot;t &quot;)
// res11: Either[Parser.Error, (String, (Char, Unit))] = Right(
//   value = (&quot;&quot;, (&#39;t&#39;, ()))
// )
// res1: Either[Error, Tuple2[String, Tuple2[Char, Unit]]] = Right((,(t,())))

/* productL, productR */

// The type is just Char because we dropping the space
// to drop the alphabet change the arrow side: alpha *&gt; sp
val p2: Parser[Char] = alpha &lt;* sp
// p2: Parser[Char] = Map(
//   parser = Prod(
//     first = CharIn(
//       min = 65,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//       ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//     ),
//     second = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$7417/1197368677@37b21776
// )

// still error since we need the space even if we drop it
p2.parse(&quot;t&quot;)
// res12: Either[Parser.Error, (String, Char)] = Left(
//   value = Error(
//     failedAtOffset = 1,
//     expected = NonEmptyList(
//       head = InRange(offset = 1, lower = &#39; &#39;, upper = &#39; &#39;),
//       tail = List()
//     )
//   )
// )
// res2: Either[Error, Tuple2[String, Char]] = Left(Error(1,NonEmptyList(InRange(1, , ))))
p2.parse(&quot;t &quot;)
// res13: Either[Parser.Error, (String, Char)] = Right(value = (&quot;&quot;, &#39;t&#39;))
// res3: Either[Error, Tuple2[String, Char]] = Right((,t))

/* surroundedBy */

val p4: Parser[Char] = sp *&gt; alpha &lt;* sp
// p4: Parser[Char] = Map(
//   parser = Prod(
//     first = Map(
//       parser = Prod(
//         first = Void(
//           parser = CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           )
//         ),
//         second = CharIn(
//           min = 65,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//           ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//         )
//       ),
//       fn = cats.parse.Parser$$Lambda$7415/957889887@2c381599
//     ),
//     second = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$7417/1197368677@37b21776
// )
val p5: Parser[Char] = alpha.surroundedBy(sp)
// p5: Parser[Char] = Map(
//   parser = Prod(
//     first = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     ),
//     second = Prod(
//       first = CharIn(
//         min = 65,
//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//         ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//       ),
//       second = Void(
//         parser = CharIn(
//           min = 32,
//           bitSet = {0},
//           ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//         )
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$7418/1070881300@6d1cee50
// )

p4.parse(&quot; a &quot;)
// res14: Either[Parser.Error, (String, Char)] = Right(value = (&quot;&quot;, &#39;a&#39;))
// res0: Either[Error, Tuple2[String, Char]] = Right((,a))
p5.parse(&quot; a &quot;)
// res15: Either[Parser.Error, (String, Char)] = Right(value = (&quot;&quot;, &#39;a&#39;))
// res1: Either[Error, Tuple2[String, Char]] = Right((,a))

/* between */

val p6: Parser[Char] = sp *&gt; alpha &lt;* digit
// p6: Parser[Char] = Map(
//   parser = Prod(
//     first = Map(
//       parser = Prod(
//         first = Void(
//           parser = CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           )
//         ),
//         second = CharIn(
//           min = 65,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//           ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//         )
//       ),
//       fn = cats.parse.Parser$$Lambda$7415/957889887@2c381599
//     ),
//     second = Void(
//       parser = CharIn(
//         min = 48,
//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//         ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$7417/1197368677@37b21776
// )
val p7: Parser[Char] = alpha.between(sp, digit)
// p7: Parser[Char] = Map(
//   parser = Prod(
//     first = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     ),
//     second = Prod(
//       first = CharIn(
//         min = 65,
//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//         ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//       ),
//       second = Void(
//         parser = CharIn(
//           min = 48,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//           ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//         )
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$7418/1070881300@6d1cee50
// )

p6.parse(&quot; a1&quot;)
// res16: Either[Parser.Error, (String, Char)] = Right(value = (&quot;&quot;, &#39;a&#39;))
// res2: Either[Error, Tuple2[String, Char]] = Right((,a))
p7.parse(&quot; a1&quot;)
// res17: Either[Parser.Error, (String, Char)] = Right(value = (&quot;&quot;, &#39;a&#39;))
// res3: Either[Error, Tuple2[String, Char]] = Right((,a))

/* OrElse */

val p3: Parser[AnyVal] = alpha | sp
// p3: Parser[AnyVal] = OneOf(
//   all = List(
//     CharIn(
//       min = 65,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//       ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//     ),
//     Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     )
//   )
// )

p3.parse(&quot;t&quot;)
// res18: Either[Parser.Error, (String, AnyVal)] = Right(value = (&quot;&quot;, &#39;t&#39;))
// res4: Either[Error, Tuple2[String, AnyVal]] = Right((,t))
p3.parse(&quot; &quot;)
// res19: Either[Parser.Error, (String, AnyVal)] = Right(value = (&quot;&quot;, ()))
</code></pre>
<h2><a href="#repeating-parsers" name="repeating-parsers" class="anchor"><span class="anchor-link"></span></a>Repeating parsers</h2>
<p>Sometimes we need something to repeat zero or more types. The cats-parse have <code>rep</code> and <code>rep0</code> methods for repeating values. <code>rep</code> means that the parser must be successful <em>at least one time</em>. <code>rep0</code> means that the parser output might be empty.</p>
<pre class="prettyprint"><code class="language-scala">import cats.data.NonEmptyList
import cats.parse.Rfc5234.alpha
import cats.parse.{Parser, Parser0}

val p1: Parser[NonEmptyList[Char]]  = alpha.rep
// p1: Parser[NonEmptyList[Char]] = Rep(
//   p1 = CharIn(
//     min = 65,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//     ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//   ),
//   min = 1,
//   maxMinusOne = 2147483647,
//   acc1 = cats.parse.Accumulator$$anon$12@44d09175
// )
val p2: Parser0[List[Char]] = alpha.rep0
// p2: Parser0[List[Char]] = Rep0(
//   p1 = CharIn(
//     min = 65,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//     ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//   ),
//   maxMinusOne = 2147483647,
//   acc = cats.parse.Accumulator0$$anon$9@36d79687
// )

p1.parse(&quot;&quot;)
// res21: Either[Parser.Error, (String, NonEmptyList[Char])] = Left(
//   value = Error(
//     failedAtOffset = 0,
//     expected = NonEmptyList(
//       head = InRange(offset = 0, lower = &#39;A&#39;, upper = &#39;Z&#39;),
//       tail = List(InRange(offset = 0, lower = &#39;a&#39;, upper = &#39;z&#39;))
//     )
//   )
// )
// Left(Error(0,NonEmptyList(InRange(0,A,Z), InRange(0,a,z))))
p2.parse(&quot;&quot;)
// res22: Either[Parser.Error, (String, List[Char])] = Right(
//   value = (&quot;&quot;, List())
// )
// Right((,List()))
p2.parse(&quot;something&quot;)
// res23: Either[Parser.Error, (String, List[Char])] = Right(
//   value = (&quot;&quot;, List(&#39;s&#39;, &#39;o&#39;, &#39;m&#39;, &#39;e&#39;, &#39;t&#39;, &#39;h&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;))
// )
</code></pre>
<p>Notice the types of parsers. <code>Parser</code> type always means some non-empty output and the output of <code>Parser0</code> might be empty.</p>
<p>One common task in this example is to parse a full line (or words) of text. In the example it is done by <code>rep</code>, and then it could be mapped to <code>String</code> in different ways:</p>
<pre class="prettyprint"><code class="language-scala">import cats.data.NonEmptyList
import cats.parse.Rfc5234.alpha
import cats.parse.Parser

val p: Parser[String]  = alpha.rep.map((l: NonEmptyList[Char]) =&gt; l.toList.mkString)
// p: Parser[String] = Map(
//   parser = Rep(
//     p1 = CharIn(
//       min = 65,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//       ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//     ),
//     min = 1,
//     maxMinusOne = 2147483647,
//     acc1 = cats.parse.Accumulator$$anon$12@64a14527
//   ),
//   fn = &lt;function1&gt;
// )

val p2: Parser[String] = alpha.rep.string
// p2: Parser[String] = StringP(
//   parser = Rep(
//     p1 = CharIn(
//       min = 65,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//       ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//     ),
//     min = 1,
//     maxMinusOne = 2147483647,
//     acc1 = cats.parse.Accumulator0$$anon$11@5337905a
//   )
// )
val p3: Parser[String] = alpha.repAs[String]
// p3: Parser[String] = Rep(
//   p1 = CharIn(
//     min = 65,
//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//     ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//   ),
//   min = 1,
//   maxMinusOne = 2147483647,
//   acc1 = cats.parse.Accumulator0$$anon$7@6ec5498d
// )
</code></pre>
<p>All three parsers will be identical in parsing results, but <code>p2</code> and <code>p3</code> are using built-in methods which will not create intermediate list. <code>rep</code> + <code>map</code> creates intermediate list which is mapped to string in this example.</p>
<h2><a href="#parsers-with-empty-output" name="parsers-with-empty-output" class="anchor"><span class="anchor-link"></span></a>Parsers with empty output</h2>
<p>Some parsers never return a value. They have a type <code>Parser0</code>. One might get this type of parser when using <code>rep0</code> or <code>.?</code> methods.</p>
<pre class="prettyprint"><code class="language-scala">import cats.parse.Rfc5234.{alpha, sp}
import cats.parse.Parser

val p: Parser[String] = (alpha.rep &lt;* sp.?).rep.string
// p: Parser[String] = StringP(
//   parser = Rep(
//     p1 = Prod(
//       first = Rep(
//         p1 = CharIn(
//           min = 65,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//           ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//         ),
//         min = 1,
//         maxMinusOne = 2147483647,
//         acc1 = cats.parse.Accumulator0$$anon$11@5337905a
//       ),
//       second = OneOf0(
//         all = List(
//           CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           ),
//           Pure(result = ())
//         )
//       )
//     ),
//     min = 1,
//     maxMinusOne = 2147483647,
//     acc1 = cats.parse.Accumulator0$$anon$11@5337905a
//   )
// )

p.parse(&quot;hello world&quot;)
// res26: Either[Parser.Error, (String, String)] = Right(
//   value = (&quot;&quot;, &quot;hello world&quot;)
// )
</code></pre>
<p>Notice the type we got - <code>Parser[String]</code>. That is because we have <code>rep</code> outside and our <code>alpha.rep</code> parser with <code>Parser</code> type is on the left side of the clause. But what if we want to parse strings with spaces at the beginning?</p>
<pre class="prettyprint"><code class="language-scala:fail">val p = (sp.? *&gt; alpha.rep &lt;* sp.?).rep.string
</code></pre>
<p>We will get an error <code>value rep is not a member of cats.parse.Parser0</code>. This happens since we have the left-side parser as optional in <code>sp.? *&gt; alpha.rep &lt;* sp.?</code> clause. This clause has a type <code>Parser0</code> which can&rsquo;t be repeated.</p>
<p>But this parser can&rsquo;t be empty because of <code>alpha.rep</code> parser, and we know it. For these types of parsers we need to use <code>with1</code> wrapper method on the <em>left side</em> of the clause:</p>
<pre class="prettyprint"><code class="language-scala">import cats.parse.Rfc5234.{alpha, sp}
import cats.parse.Parser


val p: Parser[String] = (sp.?.with1 *&gt; alpha.rep &lt;* sp.?).rep.string
// p: Parser[String] = StringP(
//   parser = Rep(
//     p1 = Prod(
//       first = OneOf0(
//         all = List(
//           CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           ),
//           Pure(result = ())
//         )
//       ),
//       second = Prod(
//         first = Rep(
//           p1 = CharIn(
//             min = 65,
//             bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//             ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//           ),
//           min = 1,
//           maxMinusOne = 2147483647,
//           acc1 = cats.parse.Accumulator0$$anon$11@5337905a
//         ),
//         second = OneOf0(
//           all = List(
//             CharIn(
//               min = 32,
//               bitSet = {0},
//               ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//             ),
//             Pure(result = ())
//           )
//         )
//       )
//     ),
//     min = 1,
//     maxMinusOne = 2147483647,
//     acc1 = cats.parse.Accumulator0$$anon$11@5337905a
//   )
// )

p.parse(&quot;hello world&quot;)
// res28: Either[Parser.Error, (String, String)] = Right(
//   value = (&quot;&quot;, &quot;hello world&quot;)
// )
// res0: Either[Error, Tuple2[String, String]] = Right((,hello world))
p.parse(&quot; hello world&quot;)
// res29: Either[Parser.Error, (String, String)] = Right(
//   value = (&quot;&quot;, &quot; hello world&quot;)
// )
</code></pre>
<p>If we have multiple <code>Parser0</code> parsers before the <code>Parser</code> - we&rsquo;d need to use parenthesis like this: <code>(sp.? ~ sp.?).with1 *&gt; alpha.rep</code>.</p>
<h2><a href="#error-handling" name="error-handling" class="anchor"><span class="anchor-link"></span></a>Error handling</h2>
<p>Parser might be interrupted by parsing error. There are two kinds of errors:  - an error that has consumed 0 characters (**epsilon failure**);  - an error that has consumed 1 or more characters (**arresting failure**) (sometimes called halting failure).</p>
<pre class="prettyprint"><code class="language-scala">import cats.parse.Rfc5234.{alpha, sp}
import cats.parse.Parser

val p1: Parser[Char] = alpha
// p1: Parser[Char] = CharIn(
//   min = 65,
//   bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//   ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
// )
val p2: Parser[Char] = sp *&gt; alpha
// p2: Parser[Char] = Map(
//   parser = Prod(
//     first = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     ),
//     second = CharIn(
//       min = 65,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//       ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$7415/957889887@2c381599
// )

// epsilon failure
p1.parse(&quot;123&quot;)
// res31: Either[Parser.Error, (String, Char)] = Left(
//   value = Error(
//     failedAtOffset = 0,
//     expected = NonEmptyList(
//       head = InRange(offset = 0, lower = &#39;A&#39;, upper = &#39;Z&#39;),
//       tail = List(InRange(offset = 0, lower = &#39;a&#39;, upper = &#39;z&#39;))
//     )
//   )
// )
// res0: Either[Error, Tuple2[String, Char]] = Left(Error(0,NonEmptyList(InRange(0,A,Z), InRange(0,a,z))))

// arresting failure
p2.parse(&quot; 1&quot;)
// res32: Either[Parser.Error, (String, Char)] = Left(
//   value = Error(
//     failedAtOffset = 1,
//     expected = NonEmptyList(
//       head = InRange(offset = 1, lower = &#39;A&#39;, upper = &#39;Z&#39;),
//       tail = List(InRange(offset = 1, lower = &#39;a&#39;, upper = &#39;z&#39;))
//     )
//   )
// )
</code></pre>
<p>We need to make this difference because the first type of error allows us to say that parser is not matching the input before we started to process it and the second error happens while parser processing the input.</p>
<h3><a href="#backtrack" name="backtrack" class="anchor"><span class="anchor-link"></span></a>Backtrack</h3>
<p>Backtrack allows us to convert an <em>arresting failure</em> to <em>epsilon failure</em>. It also rewinds the input to the offset to that used before parsing began. The resulting parser might still be combined with others. Let&rsquo;s look at the example:</p>
<pre class="prettyprint"><code class="language-scala">import cats.parse.Rfc5234.{digit, sp}

val p = sp *&gt; digit &lt;* sp
// p: cats.parse.Parser[Char] = Map(
//   parser = Prod(
//     first = Map(
//       parser = Prod(
//         first = Void(
//           parser = CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           )
//         ),
//         second = CharIn(
//           min = 48,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//           ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//         )
//       ),
//       fn = cats.parse.Parser$$Lambda$7415/957889887@2c381599
//     ),
//     second = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$7417/1197368677@37b21776
// )

p.parse(&quot; 1&quot;)
// res34: Either[cats.parse.Parser.Error, (String, Char)] = Left(
//   value = Error(
//     failedAtOffset = 2,
//     expected = NonEmptyList(
//       head = InRange(offset = 2, lower = &#39; &#39;, upper = &#39; &#39;),
//       tail = List()
//     )
//   )
// )
</code></pre>
<p><code>Parser.Error</code> contains two parameters:</p>
<pre class="prettyprint"><code class="language-scala">final case class Error(failedAtOffset: Int, expected: NonEmptyList[Expectation])

case class InRange(offset: Int, lower: Char, upper: Char) extends Expectation
</code></pre>
<p>In the error message we see the failed offset and the expected value. There is a lot of expected error types which can be found in source code.</p>
<p>One thing we can do in this situation is providing a fallback parser which can be used in case of error. We can do this by using <code>backtrack</code> (which rewinds the input, so it will be passed to fallback parser as it was before the error) and combining it with <code>orElse</code> operator:</p>
<pre class="prettyprint"><code class="language-scala">import cats.parse.Rfc5234.{digit, sp}

val p1 = sp *&gt; digit &lt;* sp
// p1: cats.parse.Parser[Char] = Map(
//   parser = Prod(
//     first = Map(
//       parser = Prod(
//         first = Void(
//           parser = CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           )
//         ),
//         second = CharIn(
//           min = 48,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//           ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//         )
//       ),
//       fn = cats.parse.Parser$$Lambda$7415/957889887@2c381599
//     ),
//     second = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$7417/1197368677@37b21776
// )
val p2 = sp *&gt; digit
// p2: cats.parse.Parser[Char] = Map(
//   parser = Prod(
//     first = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     ),
//     second = CharIn(
//       min = 48,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//       ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$7415/957889887@2c381599
// )

p1.backtrack.orElse(p2).parse(&quot; 1&quot;)
// res36: Either[cats.parse.Parser.Error, (String, Char)] = Right(
//   value = (&quot;&quot;, &#39;1&#39;)
// )
// res0: Either[Error, Tuple2[String, Char]] = Right((,1))
(p1.backtrack | p2 ).parse(&quot; 1&quot;)
// res37: Either[cats.parse.Parser.Error, (String, Char)] = Right(
//   value = (&quot;&quot;, &#39;1&#39;)
// )
</code></pre>
<p>Notice that <code>(p1.backtrack | p2)</code> clause is another parser by itself since we&rsquo;re still combining parsers by using <code>orElse</code>. </p>
<p>But we&rsquo;ve already used <code>orElse</code> in example before without any <code>backtrack</code> operator, and it worked just fine. Why do we need <code>backtrack</code> now? Let&rsquo;s look at this example:</p>
<pre class="prettyprint"><code class="language-scala">import cats.parse.Rfc5234.{digit, sp}

val p1 = sp *&gt; digit &lt;* sp
// p1: cats.parse.Parser[Char] = Map(
//   parser = Prod(
//     first = Map(
//       parser = Prod(
//         first = Void(
//           parser = CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           )
//         ),
//         second = CharIn(
//           min = 48,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//           ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//         )
//       ),
//       fn = cats.parse.Parser$$Lambda$7415/957889887@2c381599
//     ),
//     second = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$7417/1197368677@37b21776
// )
val p2 = sp *&gt; digit
// p2: cats.parse.Parser[Char] = Map(
//   parser = Prod(
//     first = Void(
//       parser = CharIn(
//         min = 32,
//         bitSet = {0},
//         ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//       )
//     ),
//     second = CharIn(
//       min = 48,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//       ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
//     )
//   ),
//   fn = cats.parse.Parser$$Lambda$7415/957889887@2c381599
// )
val p3 = digit
// p3: cats.parse.Parser[Char] = CharIn(
//   min = 48,
//   bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
//   ranges = NonEmptyList(head = (&#39;0&#39;, &#39;9&#39;), tail = List())
// )

(p1 | p2).parse(&quot; 1&quot;)
// res39: Either[cats.parse.Parser.Error, (String, Char)] = Left(
//   value = Error(
//     failedAtOffset = 2,
//     expected = NonEmptyList(
//       head = InRange(offset = 2, lower = &#39; &#39;, upper = &#39; &#39;),
//       tail = List()
//     )
//   )
// )
// res1 = Left(Error(2,NonEmptyList(InRange(2, , ))))

(p1 | p2 | p3).parse(&quot;1&quot;)
// res40: Either[cats.parse.Parser.Error, (String, Char)] = Right(
//   value = (&quot;&quot;, &#39;1&#39;)
// )
</code></pre>
<p>The first parser combination is interrupted by <em>arresting failures</em> and the second parsing combination will only suffer from <em>epsilon failures</em>. The second parser works because <code>orElse</code> and <code>|</code> operators actually allows recovering from epsilon failures, but not from arresting failures.</p>
<p>So the <code>backtrack</code> helps us where the <em>left side</em> returns arresting failure.</p>
<h3><a href="#soft" name="soft" class="anchor"><span class="anchor-link"></span></a>Soft</h3>
<p>This method might look similar to <code>backtrack</code>, but it allows us to <em>proceed</em> the parsing when the <em>right side</em> is returning an epsilon failure. It is really useful for ambiguous parsers when we can&rsquo;t really tell what exactly we are parsing before the end. Let&rsquo;s say we want to parse some input to the search engine which contains fields. This might look like &ldquo;field:search_query&rdquo;. Let&rsquo;s try to write a parser for this:</p>
<pre class="prettyprint"><code class="language-scala">import cats.parse.Rfc5234.{alpha, sp}
import cats.parse.Parser
import cats.parse.Parser.{char =&gt; pchar}

val searchWord = alpha.rep.string
// searchWord: Parser[String] = StringP(
//   parser = Rep(
//     p1 = CharIn(
//       min = 65,
//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//       ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//     ),
//     min = 1,
//     maxMinusOne = 2147483647,
//     acc1 = cats.parse.Accumulator0$$anon$11@5337905a
//   )
// )

val fieldValue = alpha.rep.string ~ pchar(&#39;:&#39;)
// fieldValue: Parser[(String, Unit)] = Prod(
//   first = StringP(
//     parser = Rep(
//       p1 = CharIn(
//         min = 65,
//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//         ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//       ),
//       min = 1,
//       maxMinusOne = 2147483647,
//       acc1 = cats.parse.Accumulator0$$anon$11@5337905a
//     )
//   ),
//   second = Void(
//     parser = CharIn(
//       min = 58,
//       bitSet = {0},
//       ranges = NonEmptyList(head = (&#39;:&#39;, &#39;:&#39;), tail = List())
//     )
//   )
// )

val p1 = fieldValue.? ~ (searchWord ~ sp.?).rep.string
// p1: cats.parse.Parser0[(Option[(String, Unit)], String)] = Prod(
//   first = OneOf0(
//     all = List(
//       Map(
//         parser = Prod(
//           first = StringP(
//             parser = Rep(
//               p1 = CharIn(
//                 min = 65,
//                 bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//                 ranges = NonEmptyList(
//                   head = (&#39;A&#39;, &#39;Z&#39;),
//                   tail = List((&#39;a&#39;, &#39;z&#39;))
//                 )
//               ),
//               min = 1,
//               maxMinusOne = 2147483647,
//               acc1 = cats.parse.Accumulator0$$anon$11@5337905a
//             )
//           ),
//           second = Void(
//             parser = CharIn(
//               min = 58,
//               bitSet = {0},
//               ranges = NonEmptyList(head = (&#39;:&#39;, &#39;:&#39;), tail = List())
//             )
//           )
//         ),
//         fn = cats.parse.Parser0$$Lambda$7409/2045989799@5b3f1480
//       ),
//       Pure(result = None)
//     )
//   ),
//   second = StringP(
//     parser = Rep(
//       p1 = Prod(
//         first = Rep(
//           p1 = CharIn(
//             min = 65,
//             bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//             ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//           ),
//           min = 1,
//           maxMinusOne = 2147483647,
//           acc1 = cats.parse.Accumulator0$$anon$11@5337905a
// ...


p1.parse(&quot;title:The Wind Has Risen&quot;)
// res42: Either[Parser.Error, (String, (Option[(String, Unit)], String))] = Right(
//   value = (&quot;&quot;, (Some(value = (&quot;title&quot;, ())), &quot;The Wind Has Risen&quot;))
// )
// res0 = Right((,(Some((title,())),The Wind Has Risen)))
p1.parse(&quot;The Wind Has Risen&quot;)
// res43: Either[Parser.Error, (String, (Option[(String, Unit)], String))] = Left(
//   value = Error(
//     failedAtOffset = 3,
//     expected = NonEmptyList(
//       head = InRange(offset = 3, lower = &#39;:&#39;, upper = &#39;:&#39;),
//       tail = List()
//     )
//   )
// )
</code></pre>
<p>This error happens because we can&rsquo;t really tell if we are parsing the <code>fieldValue</code> before we met a <code>:</code> char. We might do this with by writing two parsers, converting the first one&rsquo;s failure to epsilon failure by <code>backtrack</code> and then providing fallback parser by <code>|</code> operator (which allows the epsilon failures):</p>
<pre class="prettyprint"><code class="language-scala">val p2 = fieldValue.? ~ (searchWord ~ sp.?).rep.string
// p2: cats.parse.Parser0[(Option[(String, Unit)], String)] = Prod(
//   first = OneOf0(
//     all = List(
//       Map(
//         parser = Prod(
//           first = StringP(
//             parser = Rep(
//               p1 = CharIn(
//                 min = 65,
//                 bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//                 ranges = NonEmptyList(
//                   head = (&#39;A&#39;, &#39;Z&#39;),
//                   tail = List((&#39;a&#39;, &#39;z&#39;))
//                 )
//               ),
//               min = 1,
//               maxMinusOne = 2147483647,
//               acc1 = cats.parse.Accumulator0$$anon$11@5337905a
//             )
//           ),
//           second = Void(
//             parser = CharIn(
//               min = 58,
//               bitSet = {0},
//               ranges = NonEmptyList(head = (&#39;:&#39;, &#39;:&#39;), tail = List())
//             )
//           )
//         ),
//         fn = cats.parse.Parser0$$Lambda$7409/2045989799@5b3f1480
//       ),
//       Pure(result = None)
//     )
//   ),
//   second = StringP(
//     parser = Rep(
//       p1 = Prod(
//         first = Rep(
//           p1 = CharIn(
//             min = 65,
//             bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//             ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//           ),
//           min = 1,
//           maxMinusOne = 2147483647,
//           acc1 = cats.parse.Accumulator0$$anon$11@5337905a
// ...

val p3 = (searchWord ~ sp.?).rep.string
// p3: Parser[String] = StringP(
//   parser = Rep(
//     p1 = Prod(
//       first = Rep(
//         p1 = CharIn(
//           min = 65,
//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//           ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//         ),
//         min = 1,
//         maxMinusOne = 2147483647,
//         acc1 = cats.parse.Accumulator0$$anon$11@5337905a
//       ),
//       second = OneOf0(
//         all = List(
//           CharIn(
//             min = 32,
//             bitSet = {0},
//             ranges = NonEmptyList(head = (&#39; &#39;, &#39; &#39;), tail = List())
//           ),
//           Pure(result = ())
//         )
//       )
//     ),
//     min = 1,
//     maxMinusOne = 2147483647,
//     acc1 = cats.parse.Accumulator0$$anon$11@5337905a
//   )
// )

(p2.backtrack | p3).parse(&quot;title:The Wind Has Risen&quot;)
// res44: Either[Parser.Error, (String, Object with Serializable)] = Right(
//   value = (&quot;&quot;, (Some(value = (&quot;title&quot;, ())), &quot;The Wind Has Risen&quot;))
// )
// res0 = Right((,(Some((title,())),The Wind Has Risen)))
(p2.backtrack | p3).parse(&quot;The Wind Has Risen&quot;)
// res45: Either[Parser.Error, (String, Object with Serializable)] = Right(
//   value = (&quot;&quot;, &quot;The Wind Has Risen&quot;)
// )
</code></pre>
<p>But this problem might be resolved with <code>soft</code> method inside the first parser since the right side of it actually returns an epsilon failure itself:</p>
<pre class="prettyprint"><code class="language-scala">val fieldValueSoft = alpha.rep.string.soft ~ pchar(&#39;:&#39;)
// fieldValueSoft: Parser[(String, Unit)] = SoftProd(
//   first = StringP(
//     parser = Rep(
//       p1 = CharIn(
//         min = 65,
//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//         ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//       ),
//       min = 1,
//       maxMinusOne = 2147483647,
//       acc1 = cats.parse.Accumulator0$$anon$11@5337905a
//     )
//   ),
//   second = Void(
//     parser = CharIn(
//       min = 58,
//       bitSet = {0},
//       ranges = NonEmptyList(head = (&#39;:&#39;, &#39;:&#39;), tail = List())
//     )
//   )
// )

val p4 = fieldValueSoft.? ~ (searchWord ~ sp.?).rep.string
// p4: cats.parse.Parser0[(Option[(String, Unit)], String)] = Prod(
//   first = OneOf0(
//     all = List(
//       Map(
//         parser = SoftProd(
//           first = StringP(
//             parser = Rep(
//               p1 = CharIn(
//                 min = 65,
//                 bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//                 ranges = NonEmptyList(
//                   head = (&#39;A&#39;, &#39;Z&#39;),
//                   tail = List((&#39;a&#39;, &#39;z&#39;))
//                 )
//               ),
//               min = 1,
//               maxMinusOne = 2147483647,
//               acc1 = cats.parse.Accumulator0$$anon$11@5337905a
//             )
//           ),
//           second = Void(
//             parser = CharIn(
//               min = 58,
//               bitSet = {0},
//               ranges = NonEmptyList(head = (&#39;:&#39;, &#39;:&#39;), tail = List())
//             )
//           )
//         ),
//         fn = cats.parse.Parser0$$Lambda$7409/2045989799@5b3f1480
//       ),
//       Pure(result = None)
//     )
//   ),
//   second = StringP(
//     parser = Rep(
//       p1 = Prod(
//         first = Rep(
//           p1 = CharIn(
//             min = 65,
//             bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},
//             ranges = NonEmptyList(head = (&#39;A&#39;, &#39;Z&#39;), tail = List((&#39;a&#39;, &#39;z&#39;)))
//           ),
//           min = 1,
//           maxMinusOne = 2147483647,
//           acc1 = cats.parse.Accumulator0$$anon$11@5337905a
// ...

p4.parse(&quot;title:The Wind Has Risen&quot;)
// res46: Either[Parser.Error, (String, (Option[(String, Unit)], String))] = Right(
//   value = (&quot;&quot;, (Some(value = (&quot;title&quot;, ())), &quot;The Wind Has Risen&quot;))
// )
// res2 = Right((,(Some((title,())),The Wind Has Risen)))
p4.parse(&quot;The Wind Has Risen&quot;)
// res47: Either[Parser.Error, (String, (Option[(String, Unit)], String))] = Right(
//   value = (&quot;&quot;, (None, &quot;The Wind Has Risen&quot;))
// )
</code></pre>
<p>So when the <em>right side</em> returns an epsilon failure the <code>soft</code> method allows us to rewind parsed input and try to proceed it&rsquo;s parsing with next parsers (without changing the parser itself!).</p>
<h1><a href="#json-parser-example" name="json-parser-example" class="anchor"><span class="anchor-link"></span></a>JSON parser example</h1>
<p>Below is most of a json parser (the string unescaping is elided). This example can give you a feel for what it is like to use this library.</p>
<pre class="prettyprint"><code class="language-scala">import cats.parse.{Parser0, Parser =&gt; P, Numbers}
import org.typelevel.jawn.ast._

object Json {
  private[this] val whitespace: P[Unit] = P.charIn(&quot; \t\r\n&quot;).void
  private[this] val whitespaces0: Parser0[Unit] = whitespace.rep0.void

  val parser: P[JValue] = P.recursive[JValue] { recurse =&gt;
    val pnull = P.string(&quot;null&quot;).as(JNull)
    val bool = P.string(&quot;true&quot;).as(JBool.True).orElse(P.string(&quot;false&quot;).as(JBool.False))
    val justStr = JsonStringUtil.escapedString(&#39;&quot;&#39;)
    val str = justStr.map(JString(_))
    val num = Numbers.jsonNumber.map(JNum(_))

    val listSep: P[Unit] =
      P.char(&#39;,&#39;).soft.surroundedBy(whitespaces0).void

    def rep[A](pa: P[A]): Parser0[List[A]] =
      pa.repSep0(listSep).surroundedBy(whitespaces0)

    val list = rep(recurse).with1
      .between(P.char(&#39;[&#39;), P.char(&#39;]&#39;))
      .map { vs =&gt; JArray.fromSeq(vs) }

    val kv: P[(String, JValue)] =
      justStr ~ (P.char(&#39;:&#39;).surroundedBy(whitespaces0) *&gt; recurse)

    val obj = rep(kv).with1
      .between(P.char(&#39;{&#39;), P.char(&#39;}&#39;))
      .map { vs =&gt; JObject.fromSeq(vs) }

    P.oneOf(str :: num :: list :: obj :: bool :: pnull :: Nil)
  }

  // any whitespace followed by json followed by whitespace followed by end
  val parserFile: P[JValue] = whitespaces0.with1 *&gt; parser &lt;* (whitespaces0 ~ P.end)
}
</code></pre>
<h1><a href="#performance" name="performance" class="anchor"><span class="anchor-link"></span></a>Performance</h1>
<p>We have a benchmark suite that compares JSON parsing across several commonly used libraries. A recent (2021/11/05) result is below:</p>
<pre><code>[info] Benchmark                         Mode  Cnt    Score    Error  Units
[info] BarBench.catsParseParse           avgt    4   ≈ 10⁻⁴           ms/op
[info] BarBench.fastparseParse           avgt    4   ≈ 10⁻⁴           ms/op
[info] BarBench.jawnParse                avgt    4   ≈ 10⁻⁴           ms/op
[info] BarBench.parboiled2Parse          avgt    4   ≈ 10⁻⁴           ms/op
[info] BarBench.parsleyParseCold         avgt    4    0.064 ±  0.001  ms/op
[info] Bla25Bench.catsParseParse         avgt    4   23.095 ±  0.174  ms/op
[info] Bla25Bench.fastparseParse         avgt    4   15.622 ±  0.414  ms/op
[info] Bla25Bench.jawnParse              avgt    4    7.501 ±  0.143  ms/op
[info] Bla25Bench.parboiled2Parse        avgt    4   18.423 ±  6.094  ms/op
[info] Bla25Bench.parsleyParseCold       avgt    4   30.752 ±  0.279  ms/op
[info] CountriesBench.catsParseParse     avgt    4    7.169 ±  0.041  ms/op
[info] CountriesBench.fastparseParse     avgt    4    5.023 ±  0.023  ms/op
[info] CountriesBench.jawnParse          avgt    4    1.235 ±  0.011  ms/op
[info] CountriesBench.parboiled2Parse    avgt    4    2.936 ±  0.008  ms/op
[info] CountriesBench.parsleyParseCold   avgt    4   11.800 ±  0.162  ms/op
[info] Qux2Bench.catsParseParse          avgt    4    7.031 ±  0.599  ms/op
[info] Qux2Bench.fastparseParse          avgt    4    6.597 ±  0.031  ms/op
[info] Qux2Bench.jawnParse               avgt    4    2.227 ±  0.014  ms/op
[info] Qux2Bench.parboiled2Parse         avgt    4    5.514 ±  0.472  ms/op
[info] Qux2Bench.parsleyParseCold        avgt    4   10.327 ±  0.293  ms/op
[info] StringInBenchmarks.oneOfParse     avgt    4   88.105 ±  2.658  ns/op
[info] StringInBenchmarks.stringInParse  avgt    4  129.246 ±  1.820  ns/op
[info] Ugh10kBench.catsParseParse        avgt    4   53.679 ±  1.385  ms/op
[info] Ugh10kBench.fastparseParse        avgt    4   45.165 ±  0.356  ms/op
[info] Ugh10kBench.jawnParse             avgt    4   11.404 ±  0.068  ms/op
[info] Ugh10kBench.parboiled2Parse       avgt    4   31.984 ±  0.748  ms/op
[info] Ugh10kBench.parsleyParseCold      avgt    4   77.150 ±  1.093  ms/op
</code></pre>
<p>Note that parboiled and fastparse both use macros that make them very difficult to port to Dotty. Jawn is a specialized and optimized JSON parser, so that can be considered an upper bound on performance. Keep in mind that parser performance depends both on the parsing library but also how the parser is written, but these results suggest that this library is already quite competitive.</p>
<h1><a href="#migrating-from-fastparse" name="migrating-from-fastparse" class="anchor"><span class="anchor-link"></span></a>Migrating from Fastparse</h1>
<p>You should find all the Fastparse methods you are used to. If not, feel free to open an issue. There are a few things to keep in mind:</p>
<ol>
  <li>In fastparse, you wrap a parser in <code>P(...)</code> to make the interior lazy. Following cats, to get a lazily constructed parser use <code>Parser.defer</code> or <code>cats.Defer[Parser].defer</code>.</li>
  <li>In fastparse the <code>~</code> operator does tuple concatenation. This can be nice, but also complex to see what the resulting type is. In cats-parse, <code>~</code> always returns a Tuple2 containing the parsed values from the left and right. To recover fastparse-like behavior, use cats syntax <code>(pa, pb, pc...).tupled</code>.</li>
  <li>In fastparse, backtracking is opt-out by using cuts. In cats-parse, backtracking is opt-in using <code>.backtrack</code>. Put another way, normal product operations in cats-parse are like <code>~/</code> in fastparse.</li>
  <li>In cats-parse, using <code>*&gt;</code>, <code>&lt;*</code>, and <code>.void</code> methods can be a significant optimization: if you don&rsquo;t need a result, communicate that to the library with those methods.</li>
</ol>
<h1><a href="#getting-and-giving-help" name="getting-and-giving-help" class="anchor"><span class="anchor-link"></span></a>Getting and Giving Help</h1>
<p>We welcome new contributors and new maintainers. Please feel free to open issues and PRs. If you have any problem using the library, an issue is the best way to ask a question until we flush out more documentation.</p>
</div>
<div>
<a href="https://github.com/typelevel/cats-parse/tree/v0.3-2-0133cf6/docs/target/mdoc/index.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.3-2-0133cf6
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright (c) 2020 Typelevel
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="assets/javascripts/application.583bbe55.js"></script>
<script src="assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"."}})</script>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
