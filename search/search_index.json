{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"cats-parse"},{"location":"/index.html#cats-parse","text":"A parsing library for the cats ecosystem.\nTo use in sbt add, the following to your libraryDependencies:\n// use this snippet for the JVM\nlibraryDependencies += \"org.typelevel\" %% \"cats-parse\" % \"0.3.6\"\n\n// use this snippet for JS, or cross-building\nlibraryDependencies += \"org.typelevel\" %%% \"cats-parse\" % \"0.3.6\"\nThe API docs are published.\nWhy another parsing library? See this blog post detailing the design. To reiterate, this library has a few goals:\nCompatibility: should work on all scala platforms and recent versions. Currently it supports JVM, JS on versions 2.11, 2.12, 2.13, and 3. The core library should have minimal dependencies. Currently this library only depends on cats. Excellent performance: should be as fast or faster than any parser combinator that has comparable scala version support. Cats friendliness: method names match cats style, and out of the box support for cats typeclasses. Precise errors: following the Haskell Trifecta parsing library, backtracking is opt-in vs opt-out. This design tends to make it easier to write parsers that point correctly to failure points. Safety: by separating Parser0, a parser that may consume no input, from Parser, a parser must consume at least one character on success. Most combinators and methods can be made safer to use and less prone to runtime errors. Stability: we are very reluctant to break compatibility between versions. We want to put a minimal tax on users to stay on the latest versions.","title":"cats-parse"},{"location":"/index.html#tutorial","text":"","title":"Tutorial"},{"location":"/index.html#simple-parser","text":"The library provides a set of simple parsers which might be combined to create any parsing logic. The simplest parser is Parser.anyChar which is successful where there is one char at the input. It has type Parser[Char] which means it returns one parsed char.\nTo provide any input to parser one need to use parse method.\n```scala import cats.parse.Parser\nval p: Parser[Char] = Parser.anyChar // p: Parser[Char] = AnyChar","title":"Simple parser"}]}