{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"cats-parse"},{"location":"/index.html#cats-parse","text":"A parsing library for the cats ecosystem.\nTo use in sbt add, the following to your libraryDependencies:\n// use this snippet for the JVM\nlibraryDependencies += \"org.typelevel\" %% \"cats-parse\" % \"0.3.6\"\n\n// use this snippet for JS, or cross-building\nlibraryDependencies += \"org.typelevel\" %%% \"cats-parse\" % \"0.3.6\"\nThe API docs are published.\nWhy another parsing library? See this blog post detailing the design. To reiterate, this library has a few goals:\nCompatibility: should work on all scala platforms and recent versions. Currently it supports JVM, JS on versions 2.11, 2.12, 2.13, and 3. The core library should have minimal dependencies. Currently this library only depends on cats. Excellent performance: should be as fast or faster than any parser combinator that has comparable scala version support. Cats friendliness: method names match cats style, and out of the box support for cats typeclasses. Precise errors: following the Haskell Trifecta parsing library, backtracking is opt-in vs opt-out. This design tends to make it easier to write parsers that point correctly to failure points. Safety: by separating Parser0, a parser that may consume no input, from Parser, a parser must consume at least one character on success. Most combinators and methods can be made safer to use and less prone to runtime errors. Stability: we are very reluctant to break compatibility between versions. We want to put a minimal tax on users to stay on the latest versions.","title":"cats-parse"},{"location":"/index.html#tutorial","text":"","title":"Tutorial"},{"location":"/index.html#simple-parser","text":"The library provides a set of simple parsers which might be combined to create any parsing logic. The simplest parser is Parser.anyChar which is successful where there is one char at the input. It has type Parser[Char] which means it returns one parsed char.\nTo provide any input to parser one need to use parse method.\nimport cats.parse.Parser\n\nval p: Parser[Char] = Parser.anyChar\n// p: Parser[Char] = AnyChar\n\np.parse(\"t\")\n// res1: Either[Parser.Error, (String, Char)] = Right(value = (\"\", 't'))\n// res0: Either[Error, Tuple2[String, Char]] = Right((,t))\np.parse(\"\")\n// res2: Either[Parser.Error, (String, Char)] = Left(\n//   value = Error(\n//     failedAtOffset = 0,\n//     expected = NonEmptyList(\n//       head = InRange(offset = 0, lower = '\\u0000', upper = '\\uffff'),\n//       tail = List()\n//     )\n//   )\n// )\n// res1: Either[Error, Tuple2[String, Char]] = Left(Error(0,NonEmptyList(InRange(0,,))))\np.parse(\"two\")\n// res3: Either[Parser.Error, (String, Char)] = Right(value = (\"wo\", 't'))\nNotice the return type. Tuple2[String, Char] contains the rest of the input string and one parsed char if parsing was successful. It returns Left with error message if there was some parsing error.","title":"Simple parser"},{"location":"/index.html#mapping-output","text":"The output of the parser might be processed with map method:\nimport cats.parse.Parser\n\ncase class CharWrapper(value: Char)  \n\nval p: Parser[CharWrapper] = Parser.anyChar.map(char => CharWrapper(char))\n// p: Parser[CharWrapper] = Map(parser = AnyChar, fn = <function1>)\n\np.parse(\"t\")\n// res5: Either[Parser.Error, (String, CharWrapper)] = Right(\n//   value = (\"\", CharWrapper(value = 't'))\n// )\nThere are built-in methods for mapping the output to types String or Unit:\nimport cats.parse.Rfc5234.digit\nimport cats.parse.Parser\n\n/* String */\n\nval p2: Parser[String] = digit.map((c: Char) => c.toString)\n// p2: Parser[String] = Map(\n//   parser = CharIn(\n//     min = 48,\n//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n//     ranges = NonEmptyList(head = ('0', '9'), tail = List())\n//   ),\n//   fn = <function1>\n// )\n// is analog to\nval p3: Parser[String] = digit.string\n// p3: Parser[String] = StringP(\n//   parser = CharIn(\n//     min = 48,\n//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n//     ranges = NonEmptyList(head = ('0', '9'), tail = List())\n//   )\n// )\n\np3.parse(\"1\")\n// res7: Either[Parser.Error, (String, String)] = Right(value = (\"\", \"1\"))\n// res0: Either[Error, Tuple2[String, String]] = Right((,1))\n\n/* Unit */\n\nval p4: Parser[Unit] = digit.map(_ => ())\n// p4: Parser[Unit] = Map(\n//   parser = CharIn(\n//     min = 48,\n//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n//     ranges = NonEmptyList(head = ('0', '9'), tail = List())\n//   ),\n//   fn = <function1>\n// )\n// is analog to\nval p5: Parser[Unit] = digit.void\n// p5: Parser[Unit] = Void(\n//   parser = CharIn(\n//     min = 48,\n//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n//     ranges = NonEmptyList(head = ('0', '9'), tail = List())\n//   )\n// )\n\np5.parse(\"1\")\n// res8: Either[Parser.Error, (String, Unit)] = Right(value = (\"\", ()))","title":"Mapping output"},{"location":"/index.html#combining-parsers","text":"The parsers might be combined through operators:\n~ - product. Allows continuing parsing if the left side was successful; <*, *> - productL and productR. Works just like product but drop part of result; surroundedBy - identical to border *> parsingResult <* border; between - identical to border1 *> parsingResult <* border2; |, orElse. Parser will be successful if any of sides is successful.\nFor this example we’ll be using cats.parse.Rfc5234 package which contains such parsers as alpha (Latin alphabet) and sp (whitespace).\nimport cats.parse.Rfc5234.{sp, alpha, digit}\nimport cats.parse.Parser\n\n/* Product */\n\n// the sp parser won't return the whitespace, it just returns Unit if it successful\nval p1: Parser[(Char, Unit)] = alpha ~ sp\n// p1: Parser[(Char, Unit)] = Prod(\n//   first = CharIn(\n//     min = 65,\n//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//     ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//   ),\n//   second = Void(\n//     parser = CharIn(\n//       min = 32,\n//       bitSet = {0},\n//       ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//     )\n//   )\n// )\n\np1.parse(\"t\")\n// res10: Either[Parser.Error, (String, (Char, Unit))] = Left(\n//   value = Error(\n//     failedAtOffset = 1,\n//     expected = NonEmptyList(\n//       head = InRange(offset = 1, lower = ' ', upper = ' '),\n//       tail = List()\n//     )\n//   )\n// )\n// res0: Either[Error, Tuple2[String, Tuple2[Char, Unit]]] = Left(Error(1,NonEmptyList(InRange(1, , ))))\np1.parse(\"t \")\n// res11: Either[Parser.Error, (String, (Char, Unit))] = Right(\n//   value = (\"\", ('t', ()))\n// )\n// res1: Either[Error, Tuple2[String, Tuple2[Char, Unit]]] = Right((,(t,())))\n\n/* productL, productR */\n\n// The type is just Char because we dropping the space\n// to drop the alphabet change the arrow side: alpha *> sp\nval p2: Parser[Char] = alpha <* sp\n// p2: Parser[Char] = Map(\n//   parser = Prod(\n//     first = CharIn(\n//       min = 65,\n//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//       ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//     ),\n//     second = Void(\n//       parser = CharIn(\n//         min = 32,\n//         bitSet = {0},\n//         ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//       )\n//     )\n//   ),\n//   fn = cats.parse.Parser$$Lambda$7566/0x0000000102208040@1b70f0f2\n// )\n\n// still error since we need the space even if we drop it\np2.parse(\"t\")\n// res12: Either[Parser.Error, (String, Char)] = Left(\n//   value = Error(\n//     failedAtOffset = 1,\n//     expected = NonEmptyList(\n//       head = InRange(offset = 1, lower = ' ', upper = ' '),\n//       tail = List()\n//     )\n//   )\n// )\n// res2: Either[Error, Tuple2[String, Char]] = Left(Error(1,NonEmptyList(InRange(1, , ))))\np2.parse(\"t \")\n// res13: Either[Parser.Error, (String, Char)] = Right(value = (\"\", 't'))\n// res3: Either[Error, Tuple2[String, Char]] = Right((,t))\n\n/* surroundedBy */\n\nval p4: Parser[Char] = sp *> alpha <* sp\n// p4: Parser[Char] = Map(\n//   parser = Prod(\n//     first = Map(\n//       parser = Prod(\n//         first = Void(\n//           parser = CharIn(\n//             min = 32,\n//             bitSet = {0},\n//             ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//           )\n//         ),\n//         second = CharIn(\n//           min = 65,\n//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//           ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//         )\n//       ),\n//       fn = cats.parse.Parser$$Lambda$7564/0x00000001021f9040@27aeefc\n//     ),\n//     second = Void(\n//       parser = CharIn(\n//         min = 32,\n//         bitSet = {0},\n//         ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//       )\n//     )\n//   ),\n//   fn = cats.parse.Parser$$Lambda$7566/0x0000000102208040@1b70f0f2\n// )\nval p5: Parser[Char] = alpha.surroundedBy(sp)\n// p5: Parser[Char] = Map(\n//   parser = Prod(\n//     first = Void(\n//       parser = CharIn(\n//         min = 32,\n//         bitSet = {0},\n//         ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//       )\n//     ),\n//     second = Prod(\n//       first = CharIn(\n//         min = 65,\n//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//         ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//       ),\n//       second = Void(\n//         parser = CharIn(\n//           min = 32,\n//           bitSet = {0},\n//           ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//         )\n//       )\n//     )\n//   ),\n//   fn = cats.parse.Parser$$Lambda$7567/0x0000000102208840@26de32cd\n// )\n\np4.parse(\" a \")\n// res14: Either[Parser.Error, (String, Char)] = Right(value = (\"\", 'a'))\n// res0: Either[Error, Tuple2[String, Char]] = Right((,a))\np5.parse(\" a \")\n// res15: Either[Parser.Error, (String, Char)] = Right(value = (\"\", 'a'))\n// res1: Either[Error, Tuple2[String, Char]] = Right((,a))\n\n/* between */\n\nval p6: Parser[Char] = sp *> alpha <* digit\n// p6: Parser[Char] = Map(\n//   parser = Prod(\n//     first = Map(\n//       parser = Prod(\n//         first = Void(\n//           parser = CharIn(\n//             min = 32,\n//             bitSet = {0},\n//             ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//           )\n//         ),\n//         second = CharIn(\n//           min = 65,\n//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//           ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//         )\n//       ),\n//       fn = cats.parse.Parser$$Lambda$7564/0x00000001021f9040@27aeefc\n//     ),\n//     second = Void(\n//       parser = CharIn(\n//         min = 48,\n//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n//         ranges = NonEmptyList(head = ('0', '9'), tail = List())\n//       )\n//     )\n//   ),\n//   fn = cats.parse.Parser$$Lambda$7566/0x0000000102208040@1b70f0f2\n// )\nval p7: Parser[Char] = alpha.between(sp, digit)\n// p7: Parser[Char] = Map(\n//   parser = Prod(\n//     first = Void(\n//       parser = CharIn(\n//         min = 32,\n//         bitSet = {0},\n//         ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//       )\n//     ),\n//     second = Prod(\n//       first = CharIn(\n//         min = 65,\n//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//         ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//       ),\n//       second = Void(\n//         parser = CharIn(\n//           min = 48,\n//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n//           ranges = NonEmptyList(head = ('0', '9'), tail = List())\n//         )\n//       )\n//     )\n//   ),\n//   fn = cats.parse.Parser$$Lambda$7567/0x0000000102208840@26de32cd\n// )\n\np6.parse(\" a1\")\n// res16: Either[Parser.Error, (String, Char)] = Right(value = (\"\", 'a'))\n// res2: Either[Error, Tuple2[String, Char]] = Right((,a))\np7.parse(\" a1\")\n// res17: Either[Parser.Error, (String, Char)] = Right(value = (\"\", 'a'))\n// res3: Either[Error, Tuple2[String, Char]] = Right((,a))\n\n/* OrElse */\n\nval p3: Parser[AnyVal] = alpha | sp\n// p3: Parser[AnyVal] = OneOf(\n//   all = List(\n//     CharIn(\n//       min = 65,\n//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//       ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//     ),\n//     Void(\n//       parser = CharIn(\n//         min = 32,\n//         bitSet = {0},\n//         ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//       )\n//     )\n//   )\n// )\n\np3.parse(\"t\")\n// res18: Either[Parser.Error, (String, AnyVal)] = Right(value = (\"\", 't'))\n// res4: Either[Error, Tuple2[String, AnyVal]] = Right((,t))\np3.parse(\" \")\n// res19: Either[Parser.Error, (String, AnyVal)] = Right(value = (\"\", ()))","title":"Combining parsers"},{"location":"/index.html#repeating-parsers","text":"Sometimes we need something to repeat zero or more types. The cats-parse have rep and rep0 methods for repeating values. rep means that the parser must be successful at least one time. rep0 means that the parser output might be empty.\nimport cats.data.NonEmptyList\nimport cats.parse.Rfc5234.alpha\nimport cats.parse.{Parser, Parser0}\n\nval p1: Parser[NonEmptyList[Char]]  = alpha.rep\n// p1: Parser[NonEmptyList[Char]] = Rep(\n//   p1 = CharIn(\n//     min = 65,\n//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//     ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//   ),\n//   min = 1,\n//   maxMinusOne = 2147483647,\n//   acc1 = cats.parse.Accumulator$$anon$12@27767d0\n// )\nval p2: Parser0[List[Char]] = alpha.rep0\n// p2: Parser0[List[Char]] = Rep0(\n//   p1 = CharIn(\n//     min = 65,\n//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//     ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//   ),\n//   maxMinusOne = 2147483647,\n//   acc = cats.parse.Accumulator0$$anon$9@3348198a\n// )\n\np1.parse(\"\")\n// res21: Either[Parser.Error, (String, NonEmptyList[Char])] = Left(\n//   value = Error(\n//     failedAtOffset = 0,\n//     expected = NonEmptyList(\n//       head = InRange(offset = 0, lower = 'A', upper = 'Z'),\n//       tail = List(InRange(offset = 0, lower = 'a', upper = 'z'))\n//     )\n//   )\n// )\n// Left(Error(0,NonEmptyList(InRange(0,A,Z), InRange(0,a,z))))\np2.parse(\"\")\n// res22: Either[Parser.Error, (String, List[Char])] = Right(\n//   value = (\"\", List())\n// )\n// Right((,List()))\np2.parse(\"something\")\n// res23: Either[Parser.Error, (String, List[Char])] = Right(\n//   value = (\"\", List('s', 'o', 'm', 'e', 't', 'h', 'i', 'n', 'g'))\n// )\nNotice the types of parsers. Parser type always means some non-empty output and the output of Parser0 might be empty.\nOne common task in this example is to parse a full line (or words) of text. In the example it is done by rep, and then it could be mapped to String in different ways:\nimport cats.data.NonEmptyList\nimport cats.parse.Rfc5234.alpha\nimport cats.parse.Parser\n\nval p: Parser[String]  = alpha.rep.map((l: NonEmptyList[Char]) => l.toList.mkString)\n// p: Parser[String] = Map(\n//   parser = Rep(\n//     p1 = CharIn(\n//       min = 65,\n//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//       ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//     ),\n//     min = 1,\n//     maxMinusOne = 2147483647,\n//     acc1 = cats.parse.Accumulator$$anon$12@3d289364\n//   ),\n//   fn = <function1>\n// )\n\nval p2: Parser[String] = alpha.rep.string\n// p2: Parser[String] = StringP(\n//   parser = Rep(\n//     p1 = CharIn(\n//       min = 65,\n//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//       ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//     ),\n//     min = 1,\n//     maxMinusOne = 2147483647,\n//     acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n//   )\n// )\nval p3: Parser[String] = alpha.repAs[String]\n// p3: Parser[String] = Rep(\n//   p1 = CharIn(\n//     min = 65,\n//     bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//     ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//   ),\n//   min = 1,\n//   maxMinusOne = 2147483647,\n//   acc1 = cats.parse.Accumulator0$$anon$7@5f225dda\n// )\nAll three parsers will be identical in parsing results, but p2 and p3 are using built-in methods which will not create intermediate list. rep + map creates intermediate list which is mapped to string in this example.","title":"Repeating parsers"},{"location":"/index.html#parsers-with-empty-output","text":"Some parsers never return a value. They have a type Parser0. One might get this type of parser when using rep0 or .? methods.\nimport cats.parse.Rfc5234.{alpha, sp}\nimport cats.parse.Parser\n\nval p: Parser[String] = (alpha.rep <* sp.?).rep.string\n// p: Parser[String] = StringP(\n//   parser = Rep(\n//     p1 = Prod(\n//       first = Rep(\n//         p1 = CharIn(\n//           min = 65,\n//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//           ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//         ),\n//         min = 1,\n//         maxMinusOne = 2147483647,\n//         acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n//       ),\n//       second = OneOf0(\n//         all = List(\n//           CharIn(\n//             min = 32,\n//             bitSet = {0},\n//             ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//           ),\n//           Pure(result = ())\n//         )\n//       )\n//     ),\n//     min = 1,\n//     maxMinusOne = 2147483647,\n//     acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n//   )\n// )\n\np.parse(\"hello world\")\n// res26: Either[Parser.Error, (String, String)] = Right(\n//   value = (\"\", \"hello world\")\n// )\nNotice the type we got - Parser[String]. That is because we have rep outside and our alpha.rep parser with Parser type is on the left side of the clause. But what if we want to parse strings with spaces at the beginning?\nval p = (sp.? *> alpha.rep <* sp.?).rep.string\nWe will get an error value rep is not a member of cats.parse.Parser0. This happens since we have the left-side parser as optional in sp.? *> alpha.rep <* sp.? clause. This clause has a type Parser0 which can’t be repeated.\nBut this parser can’t be empty because of alpha.rep parser, and we know it. For these types of parsers we need to use with1 wrapper method on the left side of the clause:\nimport cats.parse.Rfc5234.{alpha, sp}\nimport cats.parse.Parser\n\n\nval p: Parser[String] = (sp.?.with1 *> alpha.rep <* sp.?).rep.string\n// p: Parser[String] = StringP(\n//   parser = Rep(\n//     p1 = Prod(\n//       first = OneOf0(\n//         all = List(\n//           CharIn(\n//             min = 32,\n//             bitSet = {0},\n//             ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//           ),\n//           Pure(result = ())\n//         )\n//       ),\n//       second = Prod(\n//         first = Rep(\n//           p1 = CharIn(\n//             min = 65,\n//             bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//             ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//           ),\n//           min = 1,\n//           maxMinusOne = 2147483647,\n//           acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n//         ),\n//         second = OneOf0(\n//           all = List(\n//             CharIn(\n//               min = 32,\n//               bitSet = {0},\n//               ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//             ),\n//             Pure(result = ())\n//           )\n//         )\n//       )\n//     ),\n//     min = 1,\n//     maxMinusOne = 2147483647,\n//     acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n//   )\n// )\n\np.parse(\"hello world\")\n// res28: Either[Parser.Error, (String, String)] = Right(\n//   value = (\"\", \"hello world\")\n// )\n// res0: Either[Error, Tuple2[String, String]] = Right((,hello world))\np.parse(\" hello world\")\n// res29: Either[Parser.Error, (String, String)] = Right(\n//   value = (\"\", \" hello world\")\n// )\nIf we have multiple Parser0 parsers before the Parser - we’d need to use parenthesis like this: (sp.? ~ sp.?).with1 *> alpha.rep.","title":"Parsers with empty output"},{"location":"/index.html#error-handling","text":"Parser might be interrupted by parsing error. There are two kinds of errors: - an error that has consumed 0 characters (**epsilon failure**); - an error that has consumed 1 or more characters (**arresting failure**) (sometimes called halting failure).\nimport cats.parse.Rfc5234.{alpha, sp}\nimport cats.parse.Parser\n\nval p1: Parser[Char] = alpha\n// p1: Parser[Char] = CharIn(\n//   min = 65,\n//   bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//   ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n// )\nval p2: Parser[Char] = sp *> alpha\n// p2: Parser[Char] = Map(\n//   parser = Prod(\n//     first = Void(\n//       parser = CharIn(\n//         min = 32,\n//         bitSet = {0},\n//         ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//       )\n//     ),\n//     second = CharIn(\n//       min = 65,\n//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//       ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//     )\n//   ),\n//   fn = cats.parse.Parser$$Lambda$7564/0x00000001021f9040@27aeefc\n// )\n\n// epsilon failure\np1.parse(\"123\")\n// res31: Either[Parser.Error, (String, Char)] = Left(\n//   value = Error(\n//     failedAtOffset = 0,\n//     expected = NonEmptyList(\n//       head = InRange(offset = 0, lower = 'A', upper = 'Z'),\n//       tail = List(InRange(offset = 0, lower = 'a', upper = 'z'))\n//     )\n//   )\n// )\n// res0: Either[Error, Tuple2[String, Char]] = Left(Error(0,NonEmptyList(InRange(0,A,Z), InRange(0,a,z))))\n\n// arresting failure\np2.parse(\" 1\")\n// res32: Either[Parser.Error, (String, Char)] = Left(\n//   value = Error(\n//     failedAtOffset = 1,\n//     expected = NonEmptyList(\n//       head = InRange(offset = 1, lower = 'A', upper = 'Z'),\n//       tail = List(InRange(offset = 1, lower = 'a', upper = 'z'))\n//     )\n//   )\n// )\nWe need to make this difference because the first type of error allows us to say that parser is not matching the input before we started to process it and the second error happens while parser processing the input.","title":"Error handling"},{"location":"/index.html#backtrack","text":"Backtrack allows us to convert an arresting failure to epsilon failure. It also rewinds the input to the offset to that used before parsing began. The resulting parser might still be combined with others. Let’s look at the example:\nimport cats.parse.Rfc5234.{digit, sp}\n\nval p = sp *> digit <* sp\n// p: cats.parse.Parser[Char] = Map(\n//   parser = Prod(\n//     first = Map(\n//       parser = Prod(\n//         first = Void(\n//           parser = CharIn(\n//             min = 32,\n//             bitSet = {0},\n//             ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//           )\n//         ),\n//         second = CharIn(\n//           min = 48,\n//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n//           ranges = NonEmptyList(head = ('0', '9'), tail = List())\n//         )\n//       ),\n//       fn = cats.parse.Parser$$Lambda$7564/0x00000001021f9040@27aeefc\n//     ),\n//     second = Void(\n//       parser = CharIn(\n//         min = 32,\n//         bitSet = {0},\n//         ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//       )\n//     )\n//   ),\n//   fn = cats.parse.Parser$$Lambda$7566/0x0000000102208040@1b70f0f2\n// )\n\np.parse(\" 1\")\n// res34: Either[cats.parse.Parser.Error, (String, Char)] = Left(\n//   value = Error(\n//     failedAtOffset = 2,\n//     expected = NonEmptyList(\n//       head = InRange(offset = 2, lower = ' ', upper = ' '),\n//       tail = List()\n//     )\n//   )\n// )\nParser.Error contains two parameters:\nfinal case class Error(failedAtOffset: Int, expected: NonEmptyList[Expectation])\n\ncase class InRange(offset: Int, lower: Char, upper: Char) extends Expectation\nIn the error message we see the failed offset and the expected value. There is a lot of expected error types which can be found in source code.\nOne thing we can do in this situation is providing a fallback parser which can be used in case of error. We can do this by using backtrack (which rewinds the input, so it will be passed to fallback parser as it was before the error) and combining it with orElse operator:\nimport cats.parse.Rfc5234.{digit, sp}\n\nval p1 = sp *> digit <* sp\n// p1: cats.parse.Parser[Char] = Map(\n//   parser = Prod(\n//     first = Map(\n//       parser = Prod(\n//         first = Void(\n//           parser = CharIn(\n//             min = 32,\n//             bitSet = {0},\n//             ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//           )\n//         ),\n//         second = CharIn(\n//           min = 48,\n//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n//           ranges = NonEmptyList(head = ('0', '9'), tail = List())\n//         )\n//       ),\n//       fn = cats.parse.Parser$$Lambda$7564/0x00000001021f9040@27aeefc\n//     ),\n//     second = Void(\n//       parser = CharIn(\n//         min = 32,\n//         bitSet = {0},\n//         ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//       )\n//     )\n//   ),\n//   fn = cats.parse.Parser$$Lambda$7566/0x0000000102208040@1b70f0f2\n// )\nval p2 = sp *> digit\n// p2: cats.parse.Parser[Char] = Map(\n//   parser = Prod(\n//     first = Void(\n//       parser = CharIn(\n//         min = 32,\n//         bitSet = {0},\n//         ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//       )\n//     ),\n//     second = CharIn(\n//       min = 48,\n//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n//       ranges = NonEmptyList(head = ('0', '9'), tail = List())\n//     )\n//   ),\n//   fn = cats.parse.Parser$$Lambda$7564/0x00000001021f9040@27aeefc\n// )\n\np1.backtrack.orElse(p2).parse(\" 1\")\n// res36: Either[cats.parse.Parser.Error, (String, Char)] = Right(\n//   value = (\"\", '1')\n// )\n// res0: Either[Error, Tuple2[String, Char]] = Right((,1))\n(p1.backtrack | p2 ).parse(\" 1\")\n// res37: Either[cats.parse.Parser.Error, (String, Char)] = Right(\n//   value = (\"\", '1')\n// )\nNotice that (p1.backtrack | p2) clause is another parser by itself since we’re still combining parsers by using orElse.\nBut we’ve already used orElse in example before without any backtrack operator, and it worked just fine. Why do we need backtrack now? Let’s look at this example:\nimport cats.parse.Rfc5234.{digit, sp}\n\nval p1 = sp *> digit <* sp\n// p1: cats.parse.Parser[Char] = Map(\n//   parser = Prod(\n//     first = Map(\n//       parser = Prod(\n//         first = Void(\n//           parser = CharIn(\n//             min = 32,\n//             bitSet = {0},\n//             ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//           )\n//         ),\n//         second = CharIn(\n//           min = 48,\n//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n//           ranges = NonEmptyList(head = ('0', '9'), tail = List())\n//         )\n//       ),\n//       fn = cats.parse.Parser$$Lambda$7564/0x00000001021f9040@27aeefc\n//     ),\n//     second = Void(\n//       parser = CharIn(\n//         min = 32,\n//         bitSet = {0},\n//         ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//       )\n//     )\n//   ),\n//   fn = cats.parse.Parser$$Lambda$7566/0x0000000102208040@1b70f0f2\n// )\nval p2 = sp *> digit\n// p2: cats.parse.Parser[Char] = Map(\n//   parser = Prod(\n//     first = Void(\n//       parser = CharIn(\n//         min = 32,\n//         bitSet = {0},\n//         ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//       )\n//     ),\n//     second = CharIn(\n//       min = 48,\n//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n//       ranges = NonEmptyList(head = ('0', '9'), tail = List())\n//     )\n//   ),\n//   fn = cats.parse.Parser$$Lambda$7564/0x00000001021f9040@27aeefc\n// )\nval p3 = digit\n// p3: cats.parse.Parser[Char] = CharIn(\n//   min = 48,\n//   bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n//   ranges = NonEmptyList(head = ('0', '9'), tail = List())\n// )\n\n(p1 | p2).parse(\" 1\")\n// res39: Either[cats.parse.Parser.Error, (String, Char)] = Left(\n//   value = Error(\n//     failedAtOffset = 2,\n//     expected = NonEmptyList(\n//       head = InRange(offset = 2, lower = ' ', upper = ' '),\n//       tail = List()\n//     )\n//   )\n// )\n// res1 = Left(Error(2,NonEmptyList(InRange(2, , ))))\n\n(p1 | p2 | p3).parse(\"1\")\n// res40: Either[cats.parse.Parser.Error, (String, Char)] = Right(\n//   value = (\"\", '1')\n// )\nThe first parser combination is interrupted by arresting failures and the second parsing combination will only suffer from epsilon failures. The second parser works because orElse and | operators actually allows recovering from epsilon failures, but not from arresting failures.\nSo the backtrack helps us where the left side returns arresting failure.","title":"Backtrack"},{"location":"/index.html#soft","text":"This method might look similar to backtrack, but it allows us to proceed the parsing when the right side is returning an epsilon failure. It is really useful for ambiguous parsers when we can’t really tell what exactly we are parsing before the end. Let’s say we want to parse some input to the search engine which contains fields. This might look like “field:search_query”. Let’s try to write a parser for this:\nimport cats.parse.Rfc5234.{alpha, sp}\nimport cats.parse.Parser\nimport cats.parse.Parser.{char => pchar}\n\nval searchWord = alpha.rep.string\n// searchWord: Parser[String] = StringP(\n//   parser = Rep(\n//     p1 = CharIn(\n//       min = 65,\n//       bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//       ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//     ),\n//     min = 1,\n//     maxMinusOne = 2147483647,\n//     acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n//   )\n// )\n\nval fieldValue = alpha.rep.string ~ pchar(':')\n// fieldValue: Parser[(String, Unit)] = Prod(\n//   first = StringP(\n//     parser = Rep(\n//       p1 = CharIn(\n//         min = 65,\n//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//         ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//       ),\n//       min = 1,\n//       maxMinusOne = 2147483647,\n//       acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n//     )\n//   ),\n//   second = Void(\n//     parser = CharIn(\n//       min = 58,\n//       bitSet = {0},\n//       ranges = NonEmptyList(head = (':', ':'), tail = List())\n//     )\n//   )\n// )\n\nval p1 = fieldValue.? ~ (searchWord ~ sp.?).rep.string\n// p1: cats.parse.Parser0[(Option[(String, Unit)], String)] = Prod(\n//   first = OneOf0(\n//     all = List(\n//       Map(\n//         parser = Prod(\n//           first = StringP(\n//             parser = Rep(\n//               p1 = CharIn(\n//                 min = 65,\n//                 bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//                 ranges = NonEmptyList(\n//                   head = ('A', 'Z'),\n//                   tail = List(('a', 'z'))\n//                 )\n//               ),\n//               min = 1,\n//               maxMinusOne = 2147483647,\n//               acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n//             )\n//           ),\n//           second = Void(\n//             parser = CharIn(\n//               min = 58,\n//               bitSet = {0},\n//               ranges = NonEmptyList(head = (':', ':'), tail = List())\n//             )\n//           )\n//         ),\n//         fn = cats.parse.Parser0$$Lambda$7558/0x00000001021fd040@79ab3ae6\n//       ),\n//       Pure(result = None)\n//     )\n//   ),\n//   second = StringP(\n//     parser = Rep(\n//       p1 = Prod(\n//         first = Rep(\n//           p1 = CharIn(\n//             min = 65,\n//             bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//             ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//           ),\n//           min = 1,\n//           maxMinusOne = 2147483647,\n//           acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n// ...\n\n\np1.parse(\"title:The Wind Has Risen\")\n// res42: Either[Parser.Error, (String, (Option[(String, Unit)], String))] = Right(\n//   value = (\"\", (Some(value = (\"title\", ())), \"The Wind Has Risen\"))\n// )\n// res0 = Right((,(Some((title,())),The Wind Has Risen)))\np1.parse(\"The Wind Has Risen\")\n// res43: Either[Parser.Error, (String, (Option[(String, Unit)], String))] = Left(\n//   value = Error(\n//     failedAtOffset = 3,\n//     expected = NonEmptyList(\n//       head = InRange(offset = 3, lower = ':', upper = ':'),\n//       tail = List()\n//     )\n//   )\n// )\nThis error happens because we can’t really tell if we are parsing the fieldValue before we met a : char. We might do this with by writing two parsers, converting the first one’s failure to epsilon failure by backtrack and then providing fallback parser by | operator (which allows the epsilon failures):\nval p2 = fieldValue.? ~ (searchWord ~ sp.?).rep.string\n// p2: cats.parse.Parser0[(Option[(String, Unit)], String)] = Prod(\n//   first = OneOf0(\n//     all = List(\n//       Map(\n//         parser = Prod(\n//           first = StringP(\n//             parser = Rep(\n//               p1 = CharIn(\n//                 min = 65,\n//                 bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//                 ranges = NonEmptyList(\n//                   head = ('A', 'Z'),\n//                   tail = List(('a', 'z'))\n//                 )\n//               ),\n//               min = 1,\n//               maxMinusOne = 2147483647,\n//               acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n//             )\n//           ),\n//           second = Void(\n//             parser = CharIn(\n//               min = 58,\n//               bitSet = {0},\n//               ranges = NonEmptyList(head = (':', ':'), tail = List())\n//             )\n//           )\n//         ),\n//         fn = cats.parse.Parser0$$Lambda$7558/0x00000001021fd040@79ab3ae6\n//       ),\n//       Pure(result = None)\n//     )\n//   ),\n//   second = StringP(\n//     parser = Rep(\n//       p1 = Prod(\n//         first = Rep(\n//           p1 = CharIn(\n//             min = 65,\n//             bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//             ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//           ),\n//           min = 1,\n//           maxMinusOne = 2147483647,\n//           acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n// ...\n\nval p3 = (searchWord ~ sp.?).rep.string\n// p3: Parser[String] = StringP(\n//   parser = Rep(\n//     p1 = Prod(\n//       first = Rep(\n//         p1 = CharIn(\n//           min = 65,\n//           bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//           ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//         ),\n//         min = 1,\n//         maxMinusOne = 2147483647,\n//         acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n//       ),\n//       second = OneOf0(\n//         all = List(\n//           CharIn(\n//             min = 32,\n//             bitSet = {0},\n//             ranges = NonEmptyList(head = (' ', ' '), tail = List())\n//           ),\n//           Pure(result = ())\n//         )\n//       )\n//     ),\n//     min = 1,\n//     maxMinusOne = 2147483647,\n//     acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n//   )\n// )\n\n(p2.backtrack | p3).parse(\"title:The Wind Has Risen\")\n// res44: Either[Parser.Error, (String, Object with Serializable)] = Right(\n//   value = (\"\", (Some(value = (\"title\", ())), \"The Wind Has Risen\"))\n// )\n// res0 = Right((,(Some((title,())),The Wind Has Risen)))\n(p2.backtrack | p3).parse(\"The Wind Has Risen\")\n// res45: Either[Parser.Error, (String, Object with Serializable)] = Right(\n//   value = (\"\", \"The Wind Has Risen\")\n// )\nBut this problem might be resolved with soft method inside the first parser since the right side of it actually returns an epsilon failure itself:\nval fieldValueSoft = alpha.rep.string.soft ~ pchar(':')\n// fieldValueSoft: Parser[(String, Unit)] = SoftProd(\n//   first = StringP(\n//     parser = Rep(\n//       p1 = CharIn(\n//         min = 65,\n//         bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//         ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//       ),\n//       min = 1,\n//       maxMinusOne = 2147483647,\n//       acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n//     )\n//   ),\n//   second = Void(\n//     parser = CharIn(\n//       min = 58,\n//       bitSet = {0},\n//       ranges = NonEmptyList(head = (':', ':'), tail = List())\n//     )\n//   )\n// )\n\nval p4 = fieldValueSoft.? ~ (searchWord ~ sp.?).rep.string\n// p4: cats.parse.Parser0[(Option[(String, Unit)], String)] = Prod(\n//   first = OneOf0(\n//     all = List(\n//       Map(\n//         parser = SoftProd(\n//           first = StringP(\n//             parser = Rep(\n//               p1 = CharIn(\n//                 min = 65,\n//                 bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//                 ranges = NonEmptyList(\n//                   head = ('A', 'Z'),\n//                   tail = List(('a', 'z'))\n//                 )\n//               ),\n//               min = 1,\n//               maxMinusOne = 2147483647,\n//               acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n//             )\n//           ),\n//           second = Void(\n//             parser = CharIn(\n//               min = 58,\n//               bitSet = {0},\n//               ranges = NonEmptyList(head = (':', ':'), tail = List())\n//             )\n//           )\n//         ),\n//         fn = cats.parse.Parser0$$Lambda$7558/0x00000001021fd040@79ab3ae6\n//       ),\n//       Pure(result = None)\n//     )\n//   ),\n//   second = StringP(\n//     parser = Rep(\n//       p1 = Prod(\n//         first = Rep(\n//           p1 = CharIn(\n//             min = 65,\n//             bitSet = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57},\n//             ranges = NonEmptyList(head = ('A', 'Z'), tail = List(('a', 'z')))\n//           ),\n//           min = 1,\n//           maxMinusOne = 2147483647,\n//           acc1 = cats.parse.Accumulator0$$anon$11@278f73b6\n// ...\n\np4.parse(\"title:The Wind Has Risen\")\n// res46: Either[Parser.Error, (String, (Option[(String, Unit)], String))] = Right(\n//   value = (\"\", (Some(value = (\"title\", ())), \"The Wind Has Risen\"))\n// )\n// res2 = Right((,(Some((title,())),The Wind Has Risen)))\np4.parse(\"The Wind Has Risen\")\n// res47: Either[Parser.Error, (String, (Option[(String, Unit)], String))] = Right(\n//   value = (\"\", (None, \"The Wind Has Risen\"))\n// )\nSo when the right side returns an epsilon failure the soft method allows us to rewind parsed input and try to proceed it’s parsing with next parsers (without changing the parser itself!).","title":"Soft"},{"location":"/index.html#json-parser-example","text":"Below is most of a json parser (the string unescaping is elided). This example can give you a feel for what it is like to use this library.\nimport cats.parse.{Parser0, Parser => P, Numbers}\nimport org.typelevel.jawn.ast._\n\nobject Json {\n  private[this] val whitespace: P[Unit] = P.charIn(\" \\t\\r\\n\").void\n  private[this] val whitespaces0: Parser0[Unit] = whitespace.rep0.void\n\n  val parser: P[JValue] = P.recursive[JValue] { recurse =>\n    val pnull = P.string(\"null\").as(JNull)\n    val bool = P.string(\"true\").as(JBool.True).orElse(P.string(\"false\").as(JBool.False))\n    val justStr = JsonStringUtil.escapedString('\"')\n    val str = justStr.map(JString(_))\n    val num = Numbers.jsonNumber.map(JNum(_))\n\n    val listSep: P[Unit] =\n      P.char(',').soft.surroundedBy(whitespaces0).void\n\n    def rep[A](pa: P[A]): Parser0[List[A]] =\n      pa.repSep0(listSep).surroundedBy(whitespaces0)\n\n    val list = rep(recurse).with1\n      .between(P.char('['), P.char(']'))\n      .map { vs => JArray.fromSeq(vs) }\n\n    val kv: P[(String, JValue)] =\n      justStr ~ (P.char(':').surroundedBy(whitespaces0) *> recurse)\n\n    val obj = rep(kv).with1\n      .between(P.char('{'), P.char('}'))\n      .map { vs => JObject.fromSeq(vs) }\n\n    P.oneOf(str :: num :: list :: obj :: bool :: pnull :: Nil)\n  }\n\n  // any whitespace followed by json followed by whitespace followed by end\n  val parserFile: P[JValue] = whitespaces0.with1 *> parser <* (whitespaces0 ~ P.end)\n}","title":"JSON parser example"},{"location":"/index.html#performance","text":"We have a benchmark suite that compares JSON parsing across several commonly used libraries. A recent (2021/11/05) result is below:\n[info] Benchmark                         Mode  Cnt    Score    Error  Units\n[info] BarBench.catsParseParse           avgt    4   ≈ 10⁻⁴           ms/op\n[info] BarBench.fastparseParse           avgt    4   ≈ 10⁻⁴           ms/op\n[info] BarBench.jawnParse                avgt    4   ≈ 10⁻⁴           ms/op\n[info] BarBench.parboiled2Parse          avgt    4   ≈ 10⁻⁴           ms/op\n[info] BarBench.parsleyParseCold         avgt    4    0.064 ±  0.001  ms/op\n[info] Bla25Bench.catsParseParse         avgt    4   23.095 ±  0.174  ms/op\n[info] Bla25Bench.fastparseParse         avgt    4   15.622 ±  0.414  ms/op\n[info] Bla25Bench.jawnParse              avgt    4    7.501 ±  0.143  ms/op\n[info] Bla25Bench.parboiled2Parse        avgt    4   18.423 ±  6.094  ms/op\n[info] Bla25Bench.parsleyParseCold       avgt    4   30.752 ±  0.279  ms/op\n[info] CountriesBench.catsParseParse     avgt    4    7.169 ±  0.041  ms/op\n[info] CountriesBench.fastparseParse     avgt    4    5.023 ±  0.023  ms/op\n[info] CountriesBench.jawnParse          avgt    4    1.235 ±  0.011  ms/op\n[info] CountriesBench.parboiled2Parse    avgt    4    2.936 ±  0.008  ms/op\n[info] CountriesBench.parsleyParseCold   avgt    4   11.800 ±  0.162  ms/op\n[info] Qux2Bench.catsParseParse          avgt    4    7.031 ±  0.599  ms/op\n[info] Qux2Bench.fastparseParse          avgt    4    6.597 ±  0.031  ms/op\n[info] Qux2Bench.jawnParse               avgt    4    2.227 ±  0.014  ms/op\n[info] Qux2Bench.parboiled2Parse         avgt    4    5.514 ±  0.472  ms/op\n[info] Qux2Bench.parsleyParseCold        avgt    4   10.327 ±  0.293  ms/op\n[info] StringInBenchmarks.oneOfParse     avgt    4   88.105 ±  2.658  ns/op\n[info] StringInBenchmarks.stringInParse  avgt    4  129.246 ±  1.820  ns/op\n[info] Ugh10kBench.catsParseParse        avgt    4   53.679 ±  1.385  ms/op\n[info] Ugh10kBench.fastparseParse        avgt    4   45.165 ±  0.356  ms/op\n[info] Ugh10kBench.jawnParse             avgt    4   11.404 ±  0.068  ms/op\n[info] Ugh10kBench.parboiled2Parse       avgt    4   31.984 ±  0.748  ms/op\n[info] Ugh10kBench.parsleyParseCold      avgt    4   77.150 ±  1.093  ms/op\nNote that parboiled and fastparse both use macros that make them very difficult to port to Dotty. Jawn is a specialized and optimized JSON parser, so that can be considered an upper bound on performance. Keep in mind that parser performance depends both on the parsing library but also how the parser is written, but these results suggest that this library is already quite competitive.","title":"Performance"},{"location":"/index.html#migrating-from-fastparse","text":"You should find all the Fastparse methods you are used to. If not, feel free to open an issue. There are a few things to keep in mind:\nIn fastparse, you wrap a parser in P(...) to make the interior lazy. Following cats, to get a lazily constructed parser use Parser.defer or cats.Defer[Parser].defer. In fastparse the ~ operator does tuple concatenation. This can be nice, but also complex to see what the resulting type is. In cats-parse, ~ always returns a Tuple2 containing the parsed values from the left and right. To recover fastparse-like behavior, use cats syntax (pa, pb, pc...).tupled. In fastparse, backtracking is opt-out by using cuts. In cats-parse, backtracking is opt-in using .backtrack. Put another way, normal product operations in cats-parse are like ~/ in fastparse. In cats-parse, using *>, <*, and .void methods can be a significant optimization: if you don’t need a result, communicate that to the library with those methods.","title":"Migrating from Fastparse"},{"location":"/index.html#getting-and-giving-help","text":"We welcome new contributors and new maintainers. Please feel free to open issues and PRs. If you have any problem using the library, an issue is the best way to ask a question until we flush out more documentation.","title":"Getting and Giving Help"}]}